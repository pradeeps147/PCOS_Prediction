# -*- coding: utf-8 -*-
"""PCOS_0.4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15BWwQY060dm6JmCC69BQvLNA1aWBSidL

mounting the google drive to give the data path
"""

#from google.colab import drive
#drive.mount('drive')

"""importing the requrired librarries"""

#importing the libraries
import numpy as np
import pandas as pd
import warnings
warnings.filterwarnings('ignore')

# Read csv file using pandas
data_load=pd.read_csv("PCOS_data.csv",delimiter=',')
data_load.head()

#features 
for colum in data_load.columns:
  print(colum)

#non invasive features

#description of the data set
data_load.describe()

#droping the irrelevent columns
dummy=data_load.iloc[:,0:2]
dummy.shape

#data=data.drop(['Sl. No','Patient File No.'], axis=1)
data=data_load.drop(dummy, axis=1)
data.shape

#removing the unwanted data points
# data['AMH(ng/mL)'] = data['AMH(ng/mL)'].astype(float)
index = data[data['AMH(ng/mL)'] == 'a'].index
# index = df[df['Character Name'] == 'Spellman'].index
data.drop(index, inplace=True)
#df['object_column'] = df['int_column'].astype(str).astype(int)

data['II    beta-HCG(mIU/mL)'] = data['II    beta-HCG(mIU/mL)'].replace('1.99.', '1.99')
data['II    beta-HCG(mIU/mL)']=data['II    beta-HCG(mIU/mL)'].astype(float)

# df[column_name].replace([old_value1, old_value2, old_value3], new_value)
#index

data['AMH(ng/mL)'] = data['AMH(ng/mL)'].astype(float)

#information of the data set
data.info

data.isnull().sum()

#droping the null values
data=data.dropna()

#non invasive features
# column=['Blood Group','Hb(g/dl)','  I   beta-HCG(mIU/mL)','II    beta-HCG(mIU/mL)','FSH(mIU/mL)','LH(mIU/mL)','FSH/LH','TSH (mIU/L)','AMH(ng/mL)',
#         'PRL(ng/mL)','Vit D3 (ng/mL)','PRG(ng/mL)','RBS(mg/dl)']
# 'PCOS (Y/N)',' Age (yrs)',
# 'Weight (Kg)','Height(Cm) ', 'BMI',

# 'Pulse rate(bpm) ',
# 'RR (breaths/min)',

# 'Cycle(R/I)',
# 'Cycle length(days)',
# 'Marraige Status (Yrs)',
# 'Pregnant(Y/N)',
# 'No. of abortions',





# 'Hip(inch)',
# 'Waist(inch)',
# 'Waist:Hip Ratio',




# 'Weight gain(Y/N)',
# 'hair growth(Y/N)',
# 'Skin darkening (Y/N)',
# 'Hair loss(Y/N)',
# 'Pimples(Y/N)',
# 'Fast food (Y/N)',
# 'Reg.Exercise(Y/N)',
# 'BP _Systolic (mmHg)',
# 'BP _Diastolic (mmHg)',
# 'Follicle No. (L)',
# 'Follicle No. (R)',
# 'Avg. F size (L) (mm)',
# 'Avg. F size (R) (mm)',
# 'Endometrium (mm)']

#top 10 non invasive features (identified with feature importence criteria)
non_invas=['Follicle No. (R)','Follicle No. (L)','hair growth(Y/N)','Skin darkening (Y/N)','Weight gain(Y/N)',
              'Cycle(R/I)','Cycle length(days)','BMI','Pimples(Y/N)','Weight (Kg)']

non_invas_df=data[non_invas]
non_invas_df

#get the target variable
#y=data.drop(['PCOS (Y/N)'],axis=1,inplace=True)
y=data.iloc[:,0]
y

import matplotlib.pyplot as plt

count_classes = pd.value_counts(y, sort = True)

count_classes.plot(kind = 'bar', rot=0)

plt.title("PCOS distribution")

plt.xticks(range(2))

plt.xlabel(" PCOS (Y/N)")

plt.ylabel("Frequency")

"""target variable is imbalenced"""

# Splitting the dataset into the Training set and Test set

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(non_invas_df, y, test_size = 0.20, random_state = 20)

#as target variable is imbalenced so creatic the synthetic data with the help of oversampling the minority data so that it will contribute equally
#in the model
print("Before OverSampling, counts of label '1': {}".format(sum(y_train == 1)))
print("Before OverSampling, counts of label '0': {} \n".format(sum(y_train == 0)))
  
# import SMOTE module from imblearn library

from imblearn.over_sampling import SMOTE
sm = SMOTE(random_state = 2)
X_train_res, y_train_res = sm.fit_resample(X_train, y_train.ravel())
  
print('After OverSampling, the shape of train_X: {}'.format(X_train_res.shape))
print('After OverSampling, the shape of train_y: {} \n'.format(y_train_res.shape))
  
print("After OverSampling, counts of label '1': {}".format(sum(y_train_res == 1)))
print("After OverSampling, counts of label '0': {}".format(sum(y_train_res == 0)))

from sklearn.ensemble import RandomForestClassifier
classifier = RandomForestClassifier(n_estimators=300,  criterion='gini', max_depth=10, min_samples_split=2, min_samples_leaf=1, 
                                  min_weight_fraction_leaf=0.0, max_features='log2', max_leaf_nodes=None, min_impurity_decrease=0.0
                                  , bootstrap=True,oob_score=False, n_jobs=1, random_state=None,
                                  verbose=0, warm_start=False, class_weight=None, ccp_alpha=0.0, max_samples=None)
#classifier
classifier.fit(X_train_res, y_train_res)

# Make pickle file of our model
import pickle
pickle.dump(classifier, open("model.pkl", "wb"))

pickled_model = pickle.load(open('model.pkl', 'rb'))
pickled_model.predict(X_test)

# #implement the XGBoost classifier

# #import XGBClassifier
# from xgboost import XGBClassifier


# # declare parameters
# params = {
            
#             'max_depth': 5,
#             'alpha': 10,
#             'learning_rate': 0.2,
#             'n_estimators':300
#         }
            
            
            
# # instantiate the classifier 
# xgb_clf = XGBClassifier(**params)



# # fit the classifier to the training data
# xgb_clf.fit(X_train_res, y_train_res)

# y_pred=xgb_clf.predict(X_test)

# Predicting the Test set results
y_pred = classifier.predict(X_test)

#calculating the evaluation matrix
from sklearn.metrics import classification_report, confusion_matrix,accuracy_score,roc_auc_score,roc_curve
print(confusion_matrix(y_test, y_pred))
print("Accuracy Score {}".format(accuracy_score(y_test,y_pred)))
print(classification_report(y_test, y_pred))


roc_auc=roc_auc_score(y_test,y_pred)
print("ROC_Score:",roc_auc)

##random forest

"""precision deteriotes of class 1"""

#plotting the ROC(Recieving operative characteristics) and AUC(area under the curve)
roc_auc = roc_auc_score(y_test, y_pred)

false_positive_rate, true_positive_rate, thresolds =roc_curve(y_test, y_pred)

plt.figure(figsize=(5, 4), dpi=80)
plt.axis('scaled')
plt.xlim([0, 1])
plt.ylim([0, 1])
plt.title("AUC & ROC Curve")
plt.plot(false_positive_rate, true_positive_rate, 'g')
plt.fill_between(false_positive_rate, true_positive_rate, facecolor='lightgreen', alpha=0.7)
plt.text(0.95, 0.05, 'AUC = %0.4f' % roc_auc, ha='right', fontsize=12, weight='bold', color='blue')
plt.xlabel("False Positive Rate")
plt.ylabel("True Positive Rate")
plt.show()

